// Code generated by "gends"; DO NOT EDIT.

package set // import "kkn.fi/set"

// Uint32Set implements a set data structure that holds uint32s.
type Uint32Set struct {
	m map[uint32]struct{}
}

// NewUint32 creates a set of uint32s initialized with given values.
func NewUint32(values ...uint32) *Uint32Set {
	s := &Uint32Set{}
	s.m = make(map[uint32]struct{})
	s.Add(values...)
	return s
}

// Add adds given values to the set.
func (s *Uint32Set) Add(values ...uint32) {
	if len(values) == 0 {
		return
	}
	for _, value := range values {
		s.m[value] = valueExists
	}
}

// Contains returns true if set holds all values and false otherwise.
func (s *Uint32Set) Contains(values ...uint32) bool {
	if len(values) == 0 {
		return false
	}
	for _, value := range values {
		if _, has := s.m[value]; !has {
			return false
		}
	}
	return true
}

// Remove removes given values from the set.
func (s *Uint32Set) Remove(values ...uint32) {
	if len(values) == 0 {
		return
	}
	for _, value := range values {
		delete(s.m, value)
	}
}

// Clear removes all values from the set.
func (s *Uint32Set) Clear() {
	s.m = make(map[uint32]struct{})
}

// Visit iterates through the set and visits all values with function f.
// Iteration will stop if function f returns false.
// Visit will return false when set is visited partially.
func (s *Uint32Set) Visit(f func(value uint32) bool) bool {
	for v := range s.m {
		if !f(v) {
			return false
		}
	}
	return true
}

// Copy returns a copy of the set.
func (s *Uint32Set) Copy() *Uint32Set {
	return NewUint32(s.Slice()...)
}

// Equals returns true if both sets are equal, but false otherwise.
func (s *Uint32Set) Equals(other *Uint32Set) bool {
	if s.Len() != other.Len() {
		return false
	}
	e := true
	other.Visit(func(value uint32) bool {
		_, e = s.m[value]
		return e
	})
	return e
}

// IsSubset returns true if given set is a subset of s.
func (s *Uint32Set) IsSubset(other *Uint32Set) bool {
	result := true
	other.Visit(func(value uint32) bool {
		_, result = s.m[value]
		return result
	})
	return result
}

// IsSuperset returns true if given set is a superset of s.
func (s *Uint32Set) IsSuperset(other *Uint32Set) bool {
	return other.IsSubset(s)
}

// Union returns a new union set of s and other.
func (s *Uint32Set) Union(other *Uint32Set) *Uint32Set {
	result := s.Copy()
	other.Visit(func(value uint32) bool {
		result.Add(value)
		return true
	})
	return result
}

// Slice returns a slice of uint32s copied from the set contents.
func (s *Uint32Set) Slice() []uint32 {
	result := make([]uint32, 0, len(s.m))
	for value := range s.m {
		result = append(result, value)
	}
	return result
}

// Len returns the size of the set.
func (s *Uint32Set) Len() int {
	return len(s.m)
}

// IsEmpty return true is set is empty, false otherwise.
func (s *Uint32Set) IsEmpty() bool {
	return len(s.m) == 0
}
